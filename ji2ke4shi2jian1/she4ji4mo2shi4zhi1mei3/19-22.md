### 19控制反转IOC、依赖反转DIP、依赖注入DI

控制反转这里的控制指的是对程序执行流程的控制，而反转指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。流程的控制权从程序员反转到了框架。

依赖注入用一句话来概括就是：不通过new的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。通过依赖注入的方式来将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。

在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高。而对象创建和依赖注入的工作，本身跟具体的业务无关，我们完全可以抽象成框架来自动完成。这个框架就是依赖注入框架，或者叫控制反转容器。

依赖反转也叫依赖倒置。大概意思就是：高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。

### 20KISS、YAGNI

KISS原则有好几个版本：

- Keep It Simple and Stupid.
- Keep It Short and Simple.
- Keep It Simple and Straightforward.

要表达的意思其实差不多：尽量保持简单。KISS原则算是一个万金油类型的设计原则，可以应用在很多场景中。它不仅经常用来指导软件开发，还经常用来指导更加广泛的系统设计、产品设计等。

代码的可读性和可维护性是衡量代码质量非常重要的两个标准。而KISS原则就是保持代码可读和可维护的重要手段。代码足够简单，也就意味着很容易读懂，bug比较难隐藏。即便出现bug，修复起来也比较简单。

不是代码行数越少就越简单，还要考虑逻辑复杂度、实现难度、代码的可读性等。本身就复杂的问题，用复杂的方法解决，并不违背KISS原则。

不要使用同事可能不懂的技术来实现代码。不要重复造轮子，要善于使用已经有的工具类库。一定不要过度设计，不要觉得简单的东西就没有技术含量。实际上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力。

YAGNI原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。当然，这并不是说我们就不需要考虑代码的扩展性。我们还是要预留好扩展点，等到需要的时候，再去实现这部分代码。

### 21DRY

DRY原则：Don’t Repeat Yourself。直译为：不要重复自己。在编程中，可以理解为：不要写重复的代码。但是，重复的代码不一定违反DRY原则，有些看似不重复的代码反而可能违反DRY原则。

实现逻辑重复、功能语义重复和代码执行重复是三种典型的代码重复情况。但是，不重复并不代表可复用。不存在任何重复的代码，并不表示里面有可复用的代码。

代码复用表示一种行为。代码的可复用性表示一段代码可被复用的特性或能力。复用和可复用性关注角度不同。代码可复用性是从代码开发者的角度来讲的，复用是从代码使用者的角度来讲的。

提高代码复用性的方法：

- 减少代码耦合，高度耦合的代码会影响到代码的复用性。
- 满足单一职责原则，越细粒度的代码，代码的通用性会越好，越容易被复用。
- 模块化，独立的模块就像一块一块的积木，更加容易复用。
- 业务与非业务逻辑分离，越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。
- 通用代码下沉，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。
- 继承、多态、抽象、封装，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。
- 应用模板等设计模式，一些设计模式，也能提高代码的复用性。

实际上，除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反我们之前讲到的 YAGNI原则。我们可以不写可复用的代码，但一定不能写重复的代码。

除此之外，有一个著名的原则，叫作Rule of Three。也就是说，第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。

### 22迪米特法则LOD

高内聚、松耦合是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发。高内聚用来指导类本身的设计，松耦合用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。

迪米特法则的英文翻译是：Law of Demeter，缩写是LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。每个模块只应该了解那些与它关系密切的模块的有限知识。不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的有限知识）。

设计原则本身没有对错，只有能否用对之说。不要为了应用设计原则而应用设计原则，我们在应用设计原则的时候，一定要具体问题具体分析。