### 15单一职责原则SRP

关于类和模块有两种理解方式。一种理解是：把模块看作比类更加抽象的概念，类也可以看作模块。另一种理解是：把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。

单一职责原则的定义描述非常简单：一个类或者模块只负责完成一个职责。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。

但是，在真正的软件开发中，没必要过于未雨绸缪，过度设计。所以，可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。

判断类是否职责单一的原则：

- 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性。
- 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想。
- 私有方法过多，要考虑能否将私有方法独立到新的类中，设置为public方法，供更多的类使用，从而提高代码的复用性。
- 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的词语来命名，这就说明类的职责定义得可能不够清晰。
- 类中大量的方法都是集中操作类中的某几个属性，那就可以考虑将这几个属性和对应的方法拆分出来。

类不是拆得越细就越好，如果拆分得过细，实际上会适得其反，反倒会降低内聚性，也会影响代码的可维护性。

### 16开闭原则OCP

开闭原则的定义是：软件实体（模块、类、方法等）应该对扩展开放、对修改关闭。说详细一点就是：添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

添加一个新功能，不可能任何模块、类、方法的代码都不修改，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。只要没有破坏原有的代码的正常运行，没有破坏原有的单元测试，就可以说，这是一个合格的代码改动。

即便我们对业务、对系统有足够的了解，那也不可能识别出所有的扩展点，即便你能识别出所有的扩展点，为这些地方都预留扩展点，这样做的成本也是不可接受的。我们没必要为一些遥远的、不一定发生的需求去提前买单，做过度设计。这里没有一个放之四海而皆准的参考标准，全凭实际的应用场景来决定。

最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求。

### 17里式替换LSP

里式替换的定义是：子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是按照协议来设计。

父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系。

几个违反里式替换原则的例子：

- 子类违背父类声明要实现的功能。
- 子类违背父类对输入、输出、异常的约定。
- 子类违背父类注释中所罗列的任何特殊说明。

拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。

### 18接口隔离ISP

接口隔离原则的定义是：客户端不应该被强迫依赖它不需要的接口。其中的客户端，可以理解为接口的调用者或者使用者。

把接口理解为一组API接口集合的场景下。在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。

把接口理解为单个API接口或函数的场景下。那接口隔离原则就可以理解为：函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。

把接口理解为OOP中的接口时。接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。