## 进程控制

### 命令行参数和环境参数

文件demo03.c

argc就是命令行参数，envp就是环境参数。

envp拿到的参数和env命令输出的参数是一样的。

```
> ./demo03 "aaa" "bbb" "ccc"
argc=4
argc=./demo03
argc=aaa
argc=bbb
argc=ccc
envp=HOSTNAME=1fa648c62058
envp=TERM=xterm
envp=LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.axa=01;36:*.oga=01;36:*.spx=01;36:*.xspf=01;36:
envp=PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
envp=PWD=/code/demo/demo03
envp=SHLVL=1
envp=HOME=/root
envp=_=./demo03
envp=OLDPWD=/code/demo/hello
```

### fork and exec

fork 创建一个新进程/子进程

- fork通过复制调用进程创建一个新进程，
- 调用进程作为父进程，新进程作为子进程，
- 这两个进程运行在不同的内存空间里面，进程间是隔离的
- 两个进程的内存地址有同样的内容（程序数据和程序指令）
- 两个进程执行内存写操作（定义新的变量并赋值，修改变量的值，定义新的函数）或者文件映射（进程间通信）的时候互不影响

父子进程的区别

子进程有自己独立的唯一的进程标识（pid）
子进程的父进程id和父进程的pid是一样的
子进程不会继承父进程的内存锁

fock 的返回值

成功时，子进程的pid返回给父进程，子进程拿到0，根据返回值就可以判断那个是父进程

失败是，父进程拿到-1，子进程不会被创建，errno变量会存储错误信息

父进程和子进程代码是一样的，子进程会从fork下一行代码继续执行

### cow 写时复制

### pid，ppid

getpid返回调用进程的pid，getppid返回调用进程的父进程pid

如果父进程在子进程执行前先跑完了，子进程的ppid就会变成1，1就是系统进程，子进程就变成孤儿进程了，被1号进程接管有可能就变成后台进程了

### vfork

vfork创建子进程并阻塞父进程，直到子进程退出

vfork 和 fork 不一样，vfork创建出来的子进程和父进程共享内存

这个方法有bug，return 0 或者什么都不写就结束，会报错

使用exit(0) _exit(0)的时候不会

