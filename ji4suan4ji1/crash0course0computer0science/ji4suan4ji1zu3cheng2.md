## 计算机

- 2021-11-09
- 01、计算机早期历史-Early Computing
- 02、电子计算机-Electronic Computing
- 03、布尔逻辑和逻辑门-Boolean Logic and Logic Gates
- 04、二进制-Representing Numbers and Letters with Binary
- 05、算术逻辑单元-How Computers Calculate-the ALU
- 06、寄存器和内存-Registers and RAM
- 07、中央处理器(CPU)-The Central Processing Unit
- 08、指令和程序-Instructions and Programs
- 09、高级CPU设计-Advanced CPU Designs
- 17、集成电路和摩尔定律-Integrated Circuits and Moore's Law
- 19、内存和储存介质-Memory and Storage

### 电子计算机

#### 机械继电器

机械继电器（mechanical relay）是用电控制机械的开关，由电路和控制电路组成。控制电路上有一个线圈，当电流流过线圈，线圈产生磁场，吸引电路上的金属机械臂，从而闭合电路。

1944年，哈佛马克1，机电计算机，最早的用途之一是给曼哈顿计划跑模拟。

继电器内的机械臂有质量，因此无法快速开关，导致计算速度受限。另一个问题是齿轮磨损，任何会动的机械都会随时间磨损。其他的问题比如，这些巨大的黑色的温暖的机器会吸引昆虫。

1947年9月，哈佛马克2型的操作员从故障的继电器中拔出一只死虫。`Grace Hopper`曾说：“从那时起，每当电脑出了问题，我们就说它出了bug（虫子）”

#### 真空管

1904年，约翰·安布罗斯·弗莱明，电子管。

电子管把两个电极装在一个气密的玻璃灯泡里。其中一个电极可以加热从而发射电子。另一个电极如果带正电荷，就会吸引电子形成电流。如果带负电荷或者中性电荷，电子就没法被吸引，越过真空区域，因此没有电流。

1906年，李·德富雷斯特，三级真空管，在弗莱明设计的两个电极之间，加入了第三个控制电极。

如果向控制电极施加正电荷，它会允许电子流动，如果向控制电极施加负电荷，它会阻止电子流动。

真空管每秒可以开闭数千次，而且真空管内没有会动的组件，这意味更少的磨损。但是真空管有点脆弱，而且像灯泡一样会烧坏。

真空管标志着计算机从机电转向电子。

1946年，宾夕法尼亚大学，ENIAC（埃尼亚克），世界上第一个可编程的电子计算机。

#### 晶体管

1947年，贝尔实验室，晶体管。

晶体管的物理学非常复杂，涉及到量子力学。

### 布尔逻辑和逻辑门

电路闭合，电流流过，代表真。电路断开，无电流流过，代表假。

晶体管可以不只是控制开关，还可以让不同大小的电流通过。

早期计算机有三进制和五进制的，问题在于，状态越多，越难区分信号。

#### 非，与，或

非（NOT），与（AND），或（OR）是布尔代数的三个基本操作。

非运算，符号`!`，反转布尔值。

非门可以用，一个接地的二极管实现。控制端输入真，电流通过二极管，最后接地，输出端输出假。控制端输入假，电流无法通过二极管，不接地，输出端输出真。

与运算，符号`&`，当两个值都为真时，结果才为真，否则输出假。

与门可以用，两个串联的二极管实现。只有当两个二极管的控制端都输入真的时候电路才可以接通。

或运算，符号`|`，当两个值有一个为真时，结果就为真，否则输出假。

或门可以用，两个并联的二极管实现。当任意一个二极管的控制端输入真的时候，电路就可以接通。

#### 异或

异或运算（XOR），符号`^`，当两个值不同时，输出真，否则输出假。

异或门可以用，一个与门串联一个非门，将二者作为一个整体，并联一个或门。
前面的与门和或门共用两个输入。这个并联线路会产生两个输出，将这两个输出作为一个另一个与门的输入，即可得到异或的结果。

### 二进制

用真和假表示1和0。

一个字节（byte）由8个二进制位（bit）构成。

32位或64位计算机表示，在处理数据时，一块处理数据是32位或64位。

1963年，ASCII，美国信息交换标准代码。

1992年，Unicode，统一码。

### 算术逻辑单元

算术逻辑单元（arithmetic and logic unit，ALU），计算机里负责运算的组件，基本其它所有的部件都用到它。

1970年，英特尔74181，第一个封装在单个芯片内的完整ALU。

ALU有两个单元，一个算术单元（arithmetic unit），一个逻辑单元（logic unit）。

#### 算术单元

##### 半加器

半加器（half adder），一个异或门并联一个与门，两个门共用两个输入。

异或门的输出记为总和，与门的输出记为进位。

然后就可以实现1+1以内的加法了：

| 输入 | 进位 | 总和 |
| --- | --- | --- |
| 0+0 | 0 | 0 |
| 0+1 | 0 | 1 |
| 1+0 | 0 | 1 |
| 1+1 | 1 | 0 |

##### 全加器

如果想处理超过1+1的运算，需要全加器（full adder）。

全加器，由两个半加器和一个或门组成，需要三个输入。

其中两个输入作为其中一个半加器的输入，输出一个总和和一个进位。

将总和和剩下的一个输入作为另一个半加器的输入，输出一个总和和一个进位。这个总和就是全加器输出的总和。

将两个进位作为或门的输入，得到全加器输出的进位。

然后就可以实现1+1+1以内的加法了：

| 输入 | 半加器1 | 半加器2 | 或门 | 进位 | 总和 |
| --- | --- | --- | --- | --- | --- |
| 0+0+0 | 0+0=00,剩0 | 0+0=00 | 0\|0=0,0 | 0 | 0 |
| 1+0+0 | 1+0=01,剩0 | 1+0=01 | 0\|0=0,1 | 0 | 1 |
| 0+1+0 | 0+1=01,剩0 | 1+0=01 | 0\|0=0,1 | 0 | 1 |
| 0+0+1 | 0+0=00,剩1 | 0+1=01 | 0\|0=0,1 | 0 | 1 |
| 1+1+0 | 1+1=10,剩0 | 0+0=00 | 1\|0=1,0 | 1 | 0 |
| 1+0+1 | 1+0=01,剩1 | 1+1=10 | 0\|1=1,0 | 1 | 0 |
| 0+1+1 | 0+1=01,剩1 | 1+1=10 | 0\|1=1,0 | 1 | 0 |
| 1+1+1 | 1+1=10,剩1 | 0+1=01 | 1\|0=1,1 | 1 | 1 |

##### 加法器

举例：8位加法器，求8位数字A和8位数字B的和。

- 将数字A的第一位和数字B的第一位输入半加器，得到进位和总和。
- 将数字A的第二位和数字B的第二位还有上一步的进位输入全加器，得到进位和总和。
- 将数字A的第三位和数字B的第三位还有上一步的进位输入全加器，得到进位和总和。
- 以此类推，把八个位都搞定。

这样的结构又叫8位行波进位加法器（8-bit ripple carry adder）。

8位行波进位加法器会输出9位结果，最后一个进位如果是1，则表示两个数之和大于8位能表示的最大数，求和结果溢出。

现代计算机用的是超前进位加法器（carry look ahead adder），电路有所不同，速度更快。

ALU一般支持：加法、带进位的加法、减法、带借位的减法、NEGATE、增量（+1）、减量（-1）、PASS THROUGH，8个操作。

简单的ALU没有乘法和除法，乘法就是多次加法。高级的ALU有专门做乘法的算术单元。

#### 逻辑单元

由大量的逻辑门组成逻辑单元，主要用于判断。

#### 算术逻辑单元

两个数据输入，一个操作代码输入，操作代码表示ALU要做什么操作，如：加减乘除。

一个数据输出，一堆标志（flag）输出，如：溢出标志（OVERFLOW）、零测试电路（ZERO）、负标志（NEGATIVE）。ALU还有其他的标志，上面三个是普遍使用的。

- 加法器的进位连接到溢出标志，如果溢出标志输出true，表示有溢出。
- 计算A-B时，零测试电路输出true，表示A和B相等。
- 计算A-B时，负标志输出true，表示A小于B。

### 寄存器和内存

随机存取存储器（random access memory，RAM），只能在有电的情况下存储东西。持久存储器（persistent memory），电源关闭时数据也不会丢失。

#### 锁存器

锁存器（and-or latch），由一个或门，一个与门、一个非门组成。需要两个输入，分别叫设置输入和复位输入。

设置输入连接或门的一个输入，复位输入连接非门的输入。或门的输出和非门的输出分别连接与门的两个输入，与门的输出就是锁存器的输出。从这个输出上接一条线到或门的另一个输入。

- 如果设置输入输入1，复位输入输入0，则锁存器输出1。
- 如果设置输入输入1，复位输入输入1，则锁存器输出0。
- 如果设置输入输入0，复位输入输入0，则锁存器输出最后设置输入的值。

也就是说锁存器存住了1bit的数据，叫它锁存是因为它锁定了一个值。放入数据的动作叫写入，拿出数据的操作叫读取。

#### 门锁

门锁（gated latch），在锁存器的基础上在加两个与门和一个非门。接受两个输入，数据输入和允许写入输入。

数据输入连接一个第一个与门的输入和非门的输入，非门的输出连接另一个与门的输入。允许写入输入连接两个与门的输入。然后第一个与门的输出作为锁存器的设置输入，另一个与门的输出作为锁存器的复位输入。

- 如果设置数据输入输入1，允许写入输入输入0，则门锁输出0。
- 如果设置数据输入输入1，允许写入输入输入1，则门锁输出1。
- 如果设置数据输入输入0，允许写入输入输入0，则门锁最后设置输入的值。
- 如果设置数据输入输入0，允许写入输入输入1，则门锁最后设置输入的值。

门锁可以存储1bit的数据。

#### 寄存器

并排放置8个门锁，可以存8bit的数据，一组这样的门锁叫寄存器。

先将所有的复位输入设置为1，然后用8条数据输入依次发送数据，然后将所有的复位输入设置为0，这样寄存器就存储了一个数字。复位输入可以共用同一跟线。

寄存器能存一个数字，这个数字有多少位，叫位宽。寄存器可以是8位，16位，32位，64位的。

#### 内存

数量庞大的门锁（比如256个）不可能线性排列，合适的排列方式是16*16的矩阵排列。

原先的允许写入输入，就不是一条线的输入了，而是变成行列两条线和一个与门的输出。用同样的技巧，可以构造一个允许读取输入。这样结合允许写入输入，就可以控制矩阵中的门锁读写数据了。

用于输入行列坐标的是多路复用器（multiplexer）。多路复用器会将输入的数字转换成坐标。用两个多路复用器就可以分别处理行列坐标了。比如输入00010011，多路复用器就会选择1行3列的位置。

这样就构成了内存的雏形，这个结构需要一个8位的地址输入，一个数据输入，一个允许写入输入，一个允许读取输入。

把8个这样的结构并排放置，整体结构需要一个8位的地址输入，一个数据输入，一个允许写入输入，一个允许读取输入，一个8bit的数据。这里的8bit的数据的每一位会分开存到上面8个子结构中去。

这样的结构构成了可寻址内存。这个可寻址内存有256个地址，每个地址能存一个8bit的数字。

这个可寻址内存就是静态随机存取存储器（SRAM），还有DRAM、flash memory、NVRAM。它们在功能上与SRAM相似，但用不同的电路存取单个位。

### 中央处理器

中央处理单元（Central Processing Unit，CPU）是计算机的核心。

微体系架构：让用一条线连接两个组件时，这条线只是所有必须线路的一个抽象。

#### 指令

程序由一个个操作组成，这些操作叫指令，它们指示计算机要做什么。如果是加法减法这样的数学指令，CPU会让ALU进行算术运算。如果是内存指令，CPU会和内存通信，然后读写数据。

数据可以以二进制存储在内存里，程序也一样。我们可以给CPU支持的所有指令分配一个ID。指令由操作代码（operation code）和数据来源组成（内存地址或寄存器）。

#### 构造一个简单CPU

- 一个RAM，假设它有16个位置，每个位置可以放8bit的数据。
- 四个8位寄存器，假设分别叫：A、B、C、D。寄存器用来临时存储数据和操作数据。
- 一个指令表，假设我们用前四位存储操作代码，后四位存储内存地址或寄存器。
- 指令地址寄存器：追踪程序运行到哪里了，存当前指令的内存地址。
- 指令寄存器：存当前的指令。

假设指令表有四个操作：读取内存数据放入寄存器A，读取内存数据放入寄存器B，将寄存器B的数据加入寄存器A，将寄存器A的数据存入内存。

#### 一个指令流程

初始化时所有的寄存器都初始化为0，RAM中存入程序。

##### 取指令阶段

取指令阶段（fetch phase）：负责拿到指令。

将指令地址寄存器连接到RAM，寄存器的值为0，因此RAM返回地址0的数据。返回的数据会被复制到指令寄存器里。

##### 解码阶段

解码阶段（decode phase）：搞清楚指令要干什么。

指令寄存器里的数据由控制单元进行解码，控制单元由一堆逻辑门构成，用途就是判断指令的操作码到底是哪一个。

假设解码一个指令的结果，操作码部分表示读取数据放入寄存器A，地址部分表示RAM第14个逻辑块。

##### 执行阶段

上面的指令就会从RAM第14个逻辑块中取出数据，放到寄存器A里去。

执行完成后，需要关闭所有电路，然后去拿下一条指令（指令地址寄存器+1），本次执行阶段结束。

#### 一个操作流程

我们假设这个操作流程是两个数字的相加。

第一步，从RAM取数据放到寄存器A。第二步，从RAM取数据放到寄存器B。

第三步，将寄存器A和寄存器B中的数字相加后放入寄存器A。

这时控制单元会将两个数据和加法指令交给ALU，进行算术逻辑运算。但是运算后的结果不能直接放到寄存器A里去，因为在电路没有断开时，寄存器A里的数据会持续输入到ALU中。所以控制单元或用一个自己的寄存器暂时保存结果，然后关闭ALU，最后把结果放入寄存器A。

第四步，将寄存器A中的数据存入RAM。

#### 时钟

时钟（clock）负责管理CPU的节奏。节奏不能太快，因为就算是电，也需要时间来传输。

时钟以精确的时间间隔触发电信号，控制单元会用这个信号推进CPU的内部操作。

CPU取指令并解码执行的速度叫时钟速度，单位是赫兹。1赫兹代表1秒一个周期。

超频可以提升CPU的效率，但是会产生散热问题。在不需要CPU全速工作的时候降频，可以省电。

### 指令和程序

CPU之所以强大，是因为它是可编程的，如果写入不同的指令，就会执行不同的任务。

#### 指令集

我们把上面那个指令表扩展一下，加入跳跃指令（jump）和停止指令（halt）。跳跃指令可以用于让程序计数器调到指定位置继续执行。停止指令可以用来停止程序。

像这样的指令还有很多，上面4位操作码最多只能支持16种指令，4位地址码最多只能支持到逻辑块16。现在CPU用两种手段解决这个问题。

第一种是用更多位表示指令，比如64位，这叫指令长度。第二种是可变指令长度，在识别到操作码之后，根据操作码判断需要获取后面多少位的数据。

1971年，英特尔4004处理器，第一次把CPU做成一个芯片。

### 高级CPU设计

早期计算机的提速方法是减少晶体管的切换时间。

现代CPU通过各种新技术，让简单指令运行更快，也能让CPU进行更复杂的运算。

英特尔4004只有46条指令，现代CPU有上千条指令和各种巧妙复杂的电路。

超高的时钟频率带来另外一个问题，如何快速传递数据给CPU，RAM成了瓶颈。

#### 缓存

旧的设计，CPU和RAM通过总线连接，这段举例可能有几厘米，但是在高时钟频率环境下，这点延迟也是不可接受的。

新的设计，在CPU里放一块内存用来暂存数据，因为CPU里空间不大，所以缓存一般只有KB或MB大小。CPU从RAM拿数据时，可以不用传一个，可以传一块。

因为数据通常是一个一个按顺序处理，所以一次拿一块数据，下一次操作是需要的数据可能就已经在缓存里了，不用再去RAM拿了。这就是局部性原理，局部性原理又分为时间局部性原理和空间局部性原理。

如果CPU需要的数据正好在缓存里，就叫缓存命中（cache hit）,如果CPU需要的数据不在缓存里就叫缓存未命中（cache miss）。

缓存也可以充当CPU内部的临时空间存储一些计算的中间值。但这会带来一个有趣的问题，缓存和RAM不一致了，这种不一致必须记录下来，之后要同步。因此缓存里每块空间有个特殊标记，叫脏位（dirty bit）。如果缓存是脏的，需要先把数据写回RAM，再读取新的数据。

#### 指令流水线

通过指令流水线技术可以提高指令的并行处理能力。但是这会导致一个问题：在读取某个数据时，另一个指令在修改这个数据。

因此流水线处理器需要先弄清数据依赖性，必要时停止流水线。

更高级点的指令流水线，会动态排序有依赖关系的指令，最小化流水线停工的时间，这叫乱序执行。

另外，跳跃指令会改变程序的执行流。

简单的流水线处理器遇到跳跃指令会停下来，等待条件值确定下来，一旦跳跃指令的结果出来了，就继续流水线。

高级流水线处理器会用会一些技巧，如果把跳跃指令看成岔路口，高级处理器会猜测哪条路的可能性大一点，然后提前把指令放进流水线，这叫推测执行。当跳跃指令的结果出来了，如果猜对了就直接执行，如果猜错了就需要清空流水线。

CPU厂商开发了复杂的方法来猜测哪条分支更有可能，这叫分支预测。现代CPU的预测正确率超过90%。

#### 超标量处理器

一个时钟周期完成多个指令。

#### 多核处理器

同时处理多个指令流。

#### 多路CPU

多个CPU同时工作。

### 集成电路和摩尔定律

#### 数字暴政

早期计算机都由独立部件组成，叫分立元件，然后不同组件再用线连在一起。

如果想提升性能，就需要加更多的部件，这导致更多电线、更复杂。

#### 集成电路

与其把多个独立的部件用电线连起来，不如把多个组件包在一起，变成一个新的独立组件。但最终还是要连接起来创造更大、更复杂的电路。

早期集成电路就是把多个晶体管组合成独立的逻辑门组件。

最早的集成电路是用金属锗做的，后来变成硅。

#### 印刷电路板

印刷电路板无需焊接或者用一大堆线，它通过蚀刻金属线的方式，把零件连接到一起。

印刷电路板和集成电路一起使用，可以大幅减少独立组件和电线，但能做到相同的功能。而且更小、更便宜、更可靠。

#### 光刻

用光把复杂的图案印到材料上，比如：半导体材料。

双极型晶体管的制作流程：

晶圆、覆盖氧化层、覆盖光刻胶、覆盖光掩膜、光照、清洗被照射过的光刻胶、清洗光掩膜、清洗氧化层露出需要处理的硅层、清洗剩余光刻胶、掺杂改变电学性质。

覆盖氧化层、覆盖光刻胶（这次图案不同）、覆盖光掩膜、光照、清洗被照射过的光刻胶、清洗光掩膜、清洗氧化层露出需要处理的部分、清洗剩余光刻胶、掺杂改变电学性质。

覆盖光刻胶（蚀刻小通道，用于放置连接不同晶体管的细小金属导线）、覆盖光掩膜、光照、清洗被照射过的光刻胶、清洗光掩膜、清洗氧化层露出需要处理的部分、金属化（放一层薄薄的金属）

覆盖光刻胶（暴露不需要的金属）、覆盖光掩膜、光照、清洗被照射过的光刻胶、清洗光掩膜、清洗暴露的金属、清洗剩余光刻胶。

这样双极型晶体管就做好了。

上文的例子只做了一个晶体管，但是现实中光刻法一次可以做上百万个细节。

光掩膜也不一定非要覆盖到光刻胶上，它可以是悬在空中的。通过光源和透镜，可以任意放大缩小投影出的图案的大小。

晶体管越小，要移动的电荷量就越少，能更快地切换状态，耗电更少。电路紧凑，意味着信号时延更低，时钟速度就可以更快。

#### 发展瓶颈

用光掩膜把图案弄到晶圆上，因为光的波长，精度已经达到极限。

当晶体管非常小，电极之间可能只距离几个原子，电子会跳过间隙，这叫量子隧道贯穿。

### 内存和储存介质

#### 内存

一般来说，电脑内存是非永久性的，断电就会丢失，所以叫易失性存储器。

#### 存储器

存储器和内存有点不同，任何写入存储器的数据，数据会一直存着，断电也不会丢失，直到被覆盖或者删除，是非易失性的。

以前是易失性的内存速度快，非易失性的存储器速度慢，但随着技术的发展，两者的差距越来越小。

#### 储存介质的发展

纸卡、延迟线存储器、磁芯、磁带、磁鼓、硬盘（磁盘）、内存层次结构、软盘、光盘、固态硬盘。

磁芯用磁化的方式，改变整个磁芯的磁场方向，用电磁感应原理检测磁芯。

磁带用磁化的方式，改变磁带一小部分的磁场方向，然后用一个读头非破坏性的检测极性。

光盘用光学原理，光盘的表面有很多小坑，造成光的不同反射，光学传感器会捕捉到，并解码为1和0。

固态硬盘用集成电路。

内存层次结构用于解决存储速度和存储成本的平衡问题。


